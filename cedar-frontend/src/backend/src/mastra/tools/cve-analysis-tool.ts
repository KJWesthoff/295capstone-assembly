/**
 * CVE Analysis Tool
 *
 * Enhanced scan analysis with NIST NVD CVE intelligence
 * - Extracts CVE IDs from scan findings
 * - Retrieves detailed CVE data with CVSS scores and exploit availability
 * - Enriches analysis with CVE ‚Üí CWE ‚Üí OWASP ‚Üí Code Examples chain
 * - Prioritizes KEV (Known Exploited Vulnerabilities) from CISA catalog
 * - Includes public exploit intelligence from Exploit-DB
 * - Provides real-world breach case studies for impact context
 */

import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import {
  preprocessScan,
  generateLLMContext,
  type RawScanResult,
} from '../lib/scan-processor';
import {
  retrieveCVEAwareContext,
  formatCompleteCVEAwareContext,
  closePgClient,
  initializePgClient,
  extractCVEIds,
  type RetrievalConfig,
} from '../lib/retrieval';

export const cveAnalysisTool = createTool({
  id: 'cve-analysis',
  description:
    'Analyzes vulnerability scans with CVE intelligence from NIST NVD. Extracts CVE IDs, retrieves CVSS scores, exploit availability, and KEV status.',
  inputSchema: z.object({
    scanData: z.string().describe('Raw vulnerability scan JSON string'),
  }),
  outputSchema: z.object({
    scanContext: z.string().describe('Preprocessed scan context for LLM'),
    securityContext: z.string().describe('Retrieved security intelligence (OWASP + CWE + CVE)'),

    // PHASE 2: Structured code examples for frontend rendering
    codeExamples: z.array(z.object({
      cwe_id: z.string(),
      language: z.string(),
      example_type: z.enum(['vulnerable', 'fixed', 'exploit']),
      code: z.string(),
      explanation: z.string(),
      source_url: z.string().optional(),
    })).describe('Raw code examples for frontend to render natively (agent can read from securityContext)'),

    metadata: z.object({
      totalFindings: z.number(),
      uniqueRules: z.number(),
      cveIdsFound: z.array(z.string()),
      cveDataRetrieved: z.number(),
      owaspEntriesRetrieved: z.number(),
      cweEntriesRetrieved: z.number(),
      codeExamplesRetrieved: z.number(),
      hasCVEData: z.boolean(),
      hasKEVs: z.boolean(),
      hasExploits: z.boolean(),
      hasBreaches: z.boolean(),
      exploitsRetrieved: z.number(),
      trivialExploits: z.number(),
      metasploitModules: z.number(),
      exploitsSeenInWild: z.number(),
      breachesRetrieved: z.number(),
      totalBreachCost: z.number(),
      totalRecordsCompromised: z.number(),
    }),
  }),
  execute: async ({ context }) => {
    // Validate environment before proceeding
    const envValidation = validateEnvironment();
    if (!envValidation.valid) {
      throw new Error(
        `Missing required environment variables: ${envValidation.missing.join(', ')}. ` +
        'Please configure your environment variables for database access.'
      );
    }
    
    // Log any warnings
    if (envValidation.warnings.length > 0) {
      console.log('‚ö†Ô∏è  Environment warnings:', envValidation.warnings.join('; '));
    }

    console.log('\nüîí Starting CVE-Aware Security Analysis...\n');

    try {
      // Parse scan data
      const scan: RawScanResult = JSON.parse(context.scanData);

      // Step 1: Preprocess scan
      console.log('üìä Preprocessing scan results...');
      const processed = preprocessScan(scan);
      console.log(
        `‚úÖ Processed ${processed.summary.totalFindings} findings into ${processed.summary.uniqueRules.length} unique types\n`
      );

      // Step 2: Extract CVE IDs from scan
      const cveIds = extractCVEIds(processed);
      console.log(`üîç Extracted ${cveIds.length} CVE references: ${cveIds.join(', ') || 'None'}\n`);

      // Step 3: Retrieve CVE-aware context
      console.log('üîç Retrieving CVE-aware security intelligence...');

      const config: RetrievalConfig = {
        connectionString: process.env.DATABASE_URL!,
        mistralApiKey: process.env.MISTRAL_API_KEY!,
        openaiApiKey: process.env.OPENAI_API_KEY!,
      };

      const {
        owaspData,
        cweData,
        cveData,
        codeExamples,
        exploitData,
        exploitStats,
        breachData,
        breachStats,
        hasCVEData,
        hasExploits,
        hasBreaches,
      } = await retrieveCVEAwareContext(processed, config, {
        owaspTopK: 3,
        cweTopK: 5,
        includeCVEDetails: true,
        includeCodeExamples: true,
        includeExploits: true,  // Enable exploit intelligence
        includeBreaches: true,  // Enable breach case studies
      });

      // Step 4: Analyze CVE data for KEV, exploits, and breaches
      const hasKEVs = cveData.some(cve => cve.is_kev);

      console.log(`‚úÖ Retrieved ${owaspData.length} OWASP entries and ${cweData.length} CWE entries`);
      console.log(`‚úÖ Retrieved ${cveData.length} CVE details and ${codeExamples.length} code examples`);

      if (hasExploits && exploitData.length > 0) {
        console.log(`üí£ Retrieved ${exploitData.length} public exploits!`);
      }

      if (hasBreaches && breachData.length > 0) {
        console.log(`üî• Retrieved ${breachData.length} breach case studies!`);
      }

      if (hasKEVs) {
        const kevCVEs = cveData.filter(cve => cve.is_kev).map(cve => cve.cve_id);
        console.log(`üî¥ ALERT: ${kevCVEs.length} CISA KEV (Known Exploited) CVEs found: ${kevCVEs.join(', ')}`);
      }

      // Step 5: Format context for LLM (now includes exploit data + breach case studies)
      console.log('\nüìÑ Formatting CVE-aware context for analysis...');
      const scanContext = generateLLMContext(processed);
      const securityContext = formatCompleteCVEAwareContext(
        owaspData,
        cweData,
        cveData,
        exploitData,
        exploitStats,
        breachData,
        breachStats
      );

      console.log('‚úÖ CVE-aware analysis complete!\n');

      return {
        scanContext,
        securityContext,

        // PHASE 2: Return structured code examples for frontend
        codeExamples: codeExamples.map(ex => ({
          cwe_id: ex.cwe_id,
          language: ex.language,
          example_type: ex.example_type as 'vulnerable' | 'fixed' | 'exploit',
          code: ex.code,
          explanation: ex.explanation,
          source_url: ex.source_url,
        })),

        metadata: {
          totalFindings: processed.summary.totalFindings,
          uniqueRules: processed.summary.uniqueRules.length,
          cveIdsFound: cveIds,
          cveDataRetrieved: cveData.length,
          owaspEntriesRetrieved: owaspData.length,
          cweEntriesRetrieved: cweData.length,
          codeExamplesRetrieved: codeExamples.length,
          hasCVEData,
          hasKEVs,
          hasExploits,
          hasBreaches,
          exploitsRetrieved: exploitData?.length || 0,
          trivialExploits: exploitStats?.trivialCount || 0,
          metasploitModules: exploitStats?.metasploitCount || 0,
          exploitsSeenInWild: exploitStats?.seenInWildCount || 0,
          breachesRetrieved: breachData?.length || 0,
          totalBreachCost: breachStats?.totalCostUsd || 0,
          totalRecordsCompromised: breachStats?.totalRecordsAffected || 0,
        },
      };
    } catch (error) {
      console.error('‚ùå Error during CVE analysis:', error);
      throw error;
    } finally {
      await closePgClient();
    }
  },
});
